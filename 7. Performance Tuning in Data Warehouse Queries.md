# 7. Performance Tuning in Data Warehouse Queries

> Write SQL queries for large datasets and optimize them using indexing, partitioning, or materialized views.

---

## Dimension Tables

### Time dimension

```sql
CREATE TABLE DimDate (
    DateID INT PRIMARY KEY,
    FullDate DATE,
    Month INT,
    Quarter VARCHAR(10),
    Year INT
);
```

### Product dimension

```sql
CREATE TABLE DimProduct (
    ProductID INT PRIMARY KEY,
    ProductName VARCHAR(100),
    Category VARCHAR(50)
);
```

### Customer dimension

```sql
CREATE TABLE DimCustomer (
    CustomerID INT PRIMARY KEY,
    Name VARCHAR(100),
    Region VARCHAR(50)
);
```

---

## Large Fact Table

```sql
CREATE TABLE FactSales (
    SaleID BIGINT PRIMARY KEY,
    ProductID INT,
    CustomerID INT,
    DateID INT,
    QuantitySold INT,
    SaleAmount DECIMAL(12,2),
    
    FOREIGN KEY (ProductID) REFERENCES DimProduct(ProductID),
    FOREIGN KEY (CustomerID) REFERENCES DimCustomer(CustomerID),
    FOREIGN KEY (DateID) REFERENCES DimDate(DateID)
);
```

---

## Step 1: Write Expensive SQL Query

This query calculates total sales per product category per year:

```sql
SELECT 
    P.Category,
    D.Year,
    SUM(F.SaleAmount) AS TotalRevenue
FROM FactSales F
JOIN DimProduct P ON F.ProductID = P.ProductID
JOIN DimDate D ON F.DateID = D.DateID
GROUP BY P.Category, D.Year;
```

---

## Step 2: Performance Tuning

### ✅ 1. Indexing

Add indexes on commonly filtered or joined columns:

```sql
-- Index for joins
CREATE INDEX idx_factsales_productid ON FactSales(ProductID);
CREATE INDEX idx_factsales_dateid ON FactSales(DateID);

-- Optional index on amount for aggregations
CREATE INDEX idx_factsales_saleamount ON FactSales(SaleAmount);

-- On dimension keys
CREATE INDEX idx_dimproduct_category ON DimProduct(Category);
CREATE INDEX idx_dimdate_year ON DimDate(Year);
```

_Use `EXPLAIN PLAN` (Oracle/PostgreSQL) or `SET STATISTICS IO ON` (SQL Server) to confirm improvement._

---

### ✅ 2. Partitioning

Partition the fact table by year or date range.

#### SQL Server: Partition by DateID or Year

```sql
-- Create partition function (by year)
CREATE PARTITION FUNCTION pf_YearRange (INT)
AS RANGE LEFT FOR VALUES (2022, 2023, 2024, 2025);
```

```sql
-- Create partition scheme
CREATE PARTITION SCHEME ps_YearRange
AS PARTITION pf_YearRange ALL TO ([PRIMARY]);
```

```sql
-- Create partitioned table (re-create FactSales)
CREATE TABLE FactSalesPartitioned (
    SaleID BIGINT PRIMARY KEY,
    ProductID INT,
    CustomerID INT,
    DateID INT,
    QuantitySold INT,
    SaleAmount DECIMAL(12,2)
) ON ps_YearRange(DateID);
```

_Result: Queries filtering by `DateID` or `Year` will scan only relevant partitions, improving query speed._

---

### ✅ 3. Materialized View (MV)

Precompute and store the result of expensive aggregations.

#### Oracle or PostgreSQL:

```sql
CREATE MATERIALIZED VIEW mv_sales_summary
BUILD IMMEDIATE
REFRESH ON DEMAND AS
SELECT 
    P.Category,
    D.Year,
    SUM(F.SaleAmount) AS TotalRevenue
FROM FactSales F
JOIN DimProduct P ON F.ProductID = P.ProductID
JOIN DimDate D ON F.DateID = D.DateID
GROUP BY P.Category, D.Year;
```

Query this instead of raw tables:

```sql
SELECT * FROM mv_sales_summary WHERE Year = 2025;
```

---

## Summary

| **Technique** | **When to Use** | **Impact** |
|---------------|-----------------|------------|
| **Indexing** | Frequent joins/filters | Speeds up lookups |
| **Partitioning** | Large tables, time-based queries | Reduces scan size |
| **Materialized Views** | Repeated complex aggregations | Precomputed results |
